# Maîtrise de ReactJS : De Zéro à Expert

- [Maîtrise de ReactJS : De Zéro à Expert](#maîtrise-de-reactjs--de-zéro-à-expert)
  - [Section 1 : Introduction à ReactJS](#section-1--introduction-à-reactjs)
    - [Section 1.1 : Qu'est-ce que ReactJS ?](#section-11--quest-ce-que-reactjs-)
    - [Section 1.2 : Installation et Configuration de l'Environnement](#section-12--installation-et-configuration-de-lenvironnement)
    - [Section 1.3 : Structure et Composants de Base de React](#section-13--structure-et-composants-de-base-de-react)
    - [Section 1.4 : Exploration de l'Écosystème React](#section-14--exploration-de-lécosystème-react)
  - [Section 2 : Les Fondamentaux de ReactJS](#section-2--les-fondamentaux-de-reactjs)
    - [Section 2.1 : JSX et Composants](#section-21--jsx-et-composants)
      - [Théorie](#théorie)
      - [Exemple](#exemple)
      - [Exercice](#exercice)
    - [Section 2.2 : État (State) et Cycle de Vie](#section-22--état-state-et-cycle-de-vie)
      - [Théorie](#théorie-1)
      - [Exemple](#exemple-1)
      - [Exercice](#exercice-1)
    - [Section 2.3 : Gestion des Événements](#section-23--gestion-des-événements)
      - [Théorie](#théorie-2)
      - [Exemple](#exemple-2)
      - [Exercice](#exercice-2)
  - [Section 3 : Approfondissement de ReactJS](#section-3--approfondissement-de-reactjs)
    - [Section 3.1 : Props et Communication entre Composants](#section-31--props-et-communication-entre-composants)
    - [Section 3.2 : Gestion de l’État Global avec Context API](#section-32--gestion-de-létat-global-avec-context-api)
    - [Section 3.3 : Routing avec React Router](#section-33--routing-avec-react-router)
  - [Section 4 : Hooks et Patterns Avancés](#section-4--hooks-et-patterns-avancés)
    - [Section 4.1 : Hooks Personnalisés](#section-41--hooks-personnalisés)
      - [Théorie](#théorie-3)
      - [Exemple](#exemple-3)
      - [Explications](#explications)
      - [Exercice](#exercice-3)
    - [Section 4.2 : Gestion des Effets avec useEffect](#section-42--gestion-des-effets-avec-useeffect)
      - [Théorie](#théorie-4)
      - [Exemple](#exemple-4)
      - [Explications](#explications-1)
      - [Exercice](#exercice-4)
    - [Section 4.3 : Contexte Avancé et Optimisation des Performances](#section-43--contexte-avancé-et-optimisation-des-performances)
      - [Théorie](#théorie-5)
      - [Exemple](#exemple-5)
      - [Explications](#explications-2)
      - [Exercice](#exercice-5)
  - [Section 5 : React et les Appels API](#section-5--react-et-les-appels-api)
    - [Section 5.1 : Fetch et Axios pour les Appels API](#section-51--fetch-et-axios-pour-les-appels-api)
    - [Section 5.2 : Gestion des États de Chargement et Erreurs](#section-52--gestion-des-états-de-chargement-et-erreurs)
    - [Section 5.3 : Hook useReducer pour la Gestion d’État Complexe](#section-53--hook-usereducer-pour-la-gestion-détat-complexe)
  - [Section 6 : Tests et Bonnes Pratiques en ReactJS](#section-6--tests-et-bonnes-pratiques-en-reactjs)
    - [Section 6.1 : Tests Unitaires avec Jest et React Testing Library](#section-61--tests-unitaires-avec-jest-et-react-testing-library)
      - [Section 6.1.1 : Introduction à Jest et React Testing Library](#section-611--introduction-à-jest-et-react-testing-library)
      - [Section 6.1.2 : Tester des Composants React avec React Testing Library](#section-612--tester-des-composants-react-avec-react-testing-library)
      - [Section 6.1.3 : Stratégies de Mocking et de Simulations d'Événements](#section-613--stratégies-de-mocking-et-de-simulations-dévénements)
    - [Section 6.2 : Bonnes Pratiques en ReactJS](#section-62--bonnes-pratiques-en-reactjs)
      - [Section 6.2.1 : Structure et Organisation du Projet](#section-621--structure-et-organisation-du-projet)
        - [Théorie](#théorie-6)
        - [Exemple](#exemple-6)
        - [Explication](#explication)
        - [Exercice](#exercice-6)
      - [Section 6.2.2 : Réutilisation des Composants et Props](#section-622--réutilisation-des-composants-et-props)
        - [Théorie](#théorie-7)
        - [Exemple](#exemple-7)
        - [Explication](#explication-1)
        - [Exercice](#exercice-7)
      - [Section 6.2.3 : Gestion Efficace des États et Performance](#section-623--gestion-efficace-des-états-et-performance)
        - [Théorie](#théorie-8)
        - [Exemple](#exemple-8)
        - [Explication](#explication-2)
        - [Exercice](#exercice-8)
      - [Section 6.2.4 : L’Importance des Tests](#section-624--limportance-des-tests)
        - [Théorie](#théorie-9)
        - [Exemple](#exemple-9)
        - [Explication](#explication-3)
        - [Exercice](#exercice-9)
      - [Section 6.2.5 : Bonnes Pratiques de Codage](#section-625--bonnes-pratiques-de-codage)
        - [Théorie](#théorie-10)
        - [Exemple](#exemple-10)
        - [Explication](#explication-4)
        - [Exercice](#exercice-10)
    - [Section 6.3 : Déploiement d'une Application React](#section-63--déploiement-dune-application-react)
      - [Section 6.3.1 : Préparation au Déploiement](#section-631--préparation-au-déploiement)
      - [Section 6.3.2 : Choix de la Plateforme de Déploiement](#section-632--choix-de-la-plateforme-de-déploiement)
      - [Section 6.3.3 : Processus de Déploiement sur Netlify](#section-633--processus-de-déploiement-sur-netlify)
  - [Section 7 : Préparation à l'Entretien d'Embauche pour Développeur ReactJS](#section-7--préparation-à-lentretien-dembauche-pour-développeur-reactjs)
    - [Section 7.1 : Questions Fréquentes en Entretien](#section-71--questions-fréquentes-en-entretien)
      - [Section 7.1.1 : Comprendre JSX](#section-711--comprendre-jsx)
        - [Théorie](#théorie-11)
        - [Exemple de Question](#exemple-de-question)
      - [Section 7.1.2 : Composants, État et Props](#section-712--composants-état-et-props)
        - [Théorie](#théorie-12)
        - [Exemple de Question](#exemple-de-question-1)
      - [Section 7.1.3 : Lifecycle et Hooks](#section-713--lifecycle-et-hooks)
        - [Théorie](#théorie-13)
        - [Exemple de Question](#exemple-de-question-2)
      - [Section 7.1.4 : Gestion de l'État et Patterns](#section-714--gestion-de-létat-et-patterns)
        - [Théorie](#théorie-14)
        - [Exemple de Question](#exemple-de-question-3)
      - [Section 7.1.5 : Performances et Optimisation](#section-715--performances-et-optimisation)
        - [Théorie](#théorie-15)
        - [Exemple de Question](#exemple-de-question-4)
      - [Section 7.1.2 : Composants, État et Props](#section-712--composants-état-et-props-1)
        - [Théorie](#théorie-16)
        - [Exemple de Question](#exemple-de-question-5)
      - [Section 7.1.3 : Lifecycle et Hooks](#section-713--lifecycle-et-hooks-1)
        - [Théorie](#théorie-17)
        - [Exemple de Question](#exemple-de-question-6)
      - [Section 7.1.4 : Gestion de l'État et Patterns](#section-714--gestion-de-létat-et-patterns-1)
        - [Théorie](#théorie-18)
        - [Exemple de Question](#exemple-de-question-7)
      - [Section 7.1.5 : Performances et Optimisation](#section-715--performances-et-optimisation-1)
        - [Théorie](#théorie-19)
        - [Exemple de Question](#exemple-de-question-8)
    - [Section 7.2 : Cas d'Usage et Projets à Présenter](#section-72--cas-dusage-et-projets-à-présenter)
      - [Théorie](#théorie-20)
      - [Section 7.2.1 : Application E-commerce](#section-721--application-e-commerce)
        - [Description du Projet](#description-du-projet)
        - [Points Clés à Discuter](#points-clés-à-discuter)
        - [Exemple d'Implémentation](#exemple-dimplémentation)
        - [Exercice](#exercice-11)
      - [Section 7.2.2 : Application de Gestion de Tâches](#section-722--application-de-gestion-de-tâches)
        - [Description du Projet](#description-du-projet-1)
        - [Points Clés à Discuter](#points-clés-à-discuter-1)
        - [Exemple d'Implémentation](#exemple-dimplémentation-1)
        - [Exercice](#exercice-12)
      - [Conseil Final](#conseil-final)
    - [Section 7.3 : Compréhension des Subtilités de ReactJS et Bonnes Pratiques](#section-73--compréhension-des-subtilités-de-reactjs-et-bonnes-pratiques)
      - [Section 7.3.1 : La Composition par Rapport à l'Héritage](#section-731--la-composition-par-rapport-à-lhéritage)
        - [Théorie](#théorie-21)
        - [Exemple](#exemple-11)
        - [Exercice](#exercice-13)
      - [Section 7.3.2 : Immutabilité de l’État](#section-732--immutabilité-de-létat)
        - [Théorie](#théorie-22)
        - [Exemple](#exemple-12)
        - [Exercice](#exercice-14)
      - [Section 7.3.3 : Utilisation de Fragments et d'Attributs Clés](#section-733--utilisation-de-fragments-et-dattributs-clés)
        - [Théorie](#théorie-23)
        - [Exemple](#exemple-13)
        - [Exercice](#exercice-15)
      - [Section 7.3.4 : Optimisation des Performances avec React.memo et useCallback](#section-734--optimisation-des-performances-avec-reactmemo-et-usecallback)
        - [Théorie](#théorie-24)
        - [Exemple](#exemple-14)
        - [Exercice](#exercice-16)
      - [Section 7.3.5 : Séparation des Préoccupations](#section-735--séparation-des-préoccupations)
        - [Théorie](#théorie-25)
        - [Exemple](#exemple-15)
        - [Exercice](#exercice-17)

---

## Section 1 : Introduction à ReactJS

### Section 1.1 : Qu'est-ce que ReactJS ?

- **Théorie :** ReactJS est une bibliothèque JavaScript open-source conçue pour créer des interfaces utilisateur interactives. Développée par Facebook en 2013, elle permet la création d'applications web et mobiles en utilisant un modèle de composants réutilisables. React se distingue par sa capacité à gérer efficacement la mise à jour du DOM (Document Object Model), offrant ainsi des performances optimisées pour les applications web dynamiques.
  
- **Exemple :** Facebook, Instagram, et WhatsApp sont des exemples de grandes applications qui utilisent ReactJS. Leurs interfaces utilisateur interactives et dynamiques sont gérées efficacement grâce à React.

- **Exercice :** Recherchez trois sites web que vous utilisez fréquemment et essayez de déterminer s'ils utilisent ReactJS. Vous pouvez utiliser des outils comme BuiltWith ou Wappalyzer pour cela.

### Section 1.2 : Installation et Configuration de l'Environnement

- **Théorie :** Pour commencer avec ReactJS, il est essentiel d'avoir Node.js et NPM (Node Package Manager) installés sur votre machine. Node.js est un environnement d'exécution JavaScript côté serveur, tandis que NPM est un gestionnaire de paquets pour JavaScript. Ensemble, ils permettent d'installer et de gérer les dépendances nécessaires pour les projets React.

- **Exemple :** Guide pas à pas pour l'installation :
  1. Téléchargez et installez Node.js depuis le site officiel (<https://nodejs.org/>).
  2. Ouvrez un terminal et vérifiez l'installation en exécutant `node -v` et `npm -v`.
  3. Installez le CLI (Command Line Interface) de `create-react-app` en exécutant `npm install -g create-react-app`.
  4. Créez un nouveau projet React en exécutant `npx create-react-app mon-app-react`.
  5. Accédez au répertoire du projet (`cd mon-app-react`) et lancez l'application en exécutant `npm start`.
  
- **Exercice :** Créez votre premier projet ReactJS. Suivez le guide ci-dessus pour installer l'environnement nécessaire et initialisez un nouveau projet React. Lancez l'application et ouvrez-la dans un navigateur pour voir le modèle par défaut de `create-react-app`.

### Section 1.3 : Structure et Composants de Base de React

- **Théorie :** Un projet React est généralement structuré en plusieurs dossiers et fichiers. Le dossier `src` est où la majorité du code source réside, contenant les composants, les styles, les images, etc. Un composant React peut être pensé comme une unité autonome qui encapsule le rendu et la logique d'une partie de l'interface utilisateur.

- **Exemple :**
  - Structure typique :

    ```
    mon-app-react/
    ├── node_modules/
    ├── public/
    ├── src/
    │   ├── App.js
    │   ├── App.css
    │   ├── index.js
    │   └── ...
    ├── package.json
    └── ...
    ```

  - Composant de base :

    ```javascript
    import React from 'react';

    function HelloWorld() {
      return <h1>Hello, World!</h1>;
    }

    export default HelloWorld;
    ```

- **Exercice :** Explorez la structure du projet que vous avez créé. Identifiez les fichiers principaux comme `index.js`, `App.js` et `App.css`. Modifiez le composant `App.js` pour afficher "Bonjour, monde !" au lieu du contenu par défaut. Lancez votre application pour voir les changements.

### Section 1.4 : Exploration de l'Écosystème React

- **Théorie :** L'écosystème de ReactJS est vaste et comprend de nombreux outils, bibliothèques et frameworks. Des outils comme Redux pour la gestion de l'état global, React Router pour le routage, et des bibliothèques d'interface utilisateur comme Material-UI ou Ant Design sont souvent utilisés en tandem avec React pour créer des applications complètes.

- **Exemple :** Présentation de quelques outils populaires :
  - **Redux** : Une bibliothèque de gestion d'état pour les applications JavaScript.
  - **React Router** : Gère la navigation dans les applications React.
  - **Material-UI** : Une bibliothèque de composants d'interface utilisateur.

- **Exercice :** Faites des recherches sur l'un des outils mentionnés ci-dessus. Essayez de comprendre son rôle et son utilité dans le développement d'applications React. Si possible, intégrez un petit exemple de cet outil dans votre projet React actuel.

Ce premier chapitre pose les bases de ReactJS et prépare le terrain pour une exploration plus approfondie des concepts et des fonctionnalités avancées de React dans les sections suivantes.

---

## Section 2 : Les Fondamentaux de ReactJS

---

### Section 2.1 : JSX et Composants

#### Théorie

- **JSX :** JSX est une extension syntaxique de JavaScript utilisée avec React pour décrire ce que l'interface utilisateur devrait ressembler. JSX ressemble à du HTML, mais il permet d'incorporer des expressions JavaScript directement.
- **Composants :** Les composants sont les briques de base des applications React. Ils encapsulent une partie de l'interface utilisateur. Il existe deux types de composants :
  - **Composants Fonctionnels :** Ils sont écrits sous forme de fonctions JavaScript et peuvent utiliser les hooks pour gérer l'état et les effets secondaires.
  - **Composants de Classe :** Ils sont écrits sous forme de classes et utilisent les méthodes de cycle de vie pour gérer l'état et les effets secondaires.

#### Exemple

- **JSX :**

  ```jsx
  const element = <h1>Bonjour, monde !</h1>;
  ```

- **Composant Fonctionnel :**

  ```jsx
  function Welcome(props) {
    return <h1>Bonjour, {props.name}</h1>;
  }
  ```

#### Exercice

- Créez un composant "Carte de Visite" qui affiche le nom, la profession, et une courte description. Utilisez les props pour passer ces données.

---

### Section 2.2 : État (State) et Cycle de Vie

#### Théorie

- **État (State) :** L'état est un objet qui représente une partie de l'interface utilisateur qui peut changer au fil du temps. Chaque composant peut avoir son propre état.
- **Cycle de Vie :** Les composants de classe en React ont plusieurs méthodes de cycle de vie qui sont appelées à différentes étapes de la vie d'un composant, telles que `componentDidMount`, `componentDidUpdate`, et `componentWillUnmount`.

#### Exemple

- **État avec un Composant Fonctionnel :**

  ```jsx
  function Counter() {
    const [count, setCount] = useState(0);
    return (
      <div>
        <p>Vous avez cliqué {count} fois</p>
        <button onClick={() => setCount(count + 1)}>Cliquez ici</button>
      </div>
    );
  }
  ```

#### Exercice

- Créez une horloge numérique qui affiche l'heure actuelle et se met à jour chaque seconde. Utilisez le hook `useState` pour l'état et `useEffect` pour mettre à jour l'heure.

---

### Section 2.3 : Gestion des Événements

#### Théorie

- En React, les événements sont gérés en utilisant des propriétés spéciales sur les éléments JSX. Ces propriétés ont des noms comme `onClick`, `onChange`, etc. Les gestionnaires d'événements sont des fonctions JavaScript.

#### Exemple

- **Bouton avec un Gestionnaire d'Événements :**

  ```jsx
  function App() {
    function handleClick() {
      alert('Bouton cliqué !');
    }

    return <button onClick={handleClick}>Cliquez sur moi</button>;
  }
  ```

#### Exercice

- Créez un formulaire d'inscription avec des champs pour le nom, l'email, et un mot de passe. Ajoutez des gestionnaires d'événements pour valider les données entrées par l'utilisateur avant de soumettre le formulaire. Affichez des messages d'erreur appropriés si les données ne sont pas valides.

---

## Section 3 : Approfondissement de ReactJS

### Section 3.1 : Props et Communication entre Composants

- **Théorie :**
  - Les props (abréviation de "propriétés") sont le moyen principal de passer des données d'un composant parent à un composant enfant dans ReactJS. Ils sont en lecture seule, ce qui signifie qu'un composant enfant ne peut pas les modifier directement.
  - Les props favorisent la réutilisabilité des composants en permettant de leur passer des données dynamiques. Ils rendent les composants plus flexibles et maintenables.

- **Exemple :**
  - Imaginons un composant `CarteUtilisateur` qui affiche le nom et l'âge d'un utilisateur. Ce composant pourrait être utilisé à plusieurs endroits dans une application, chaque fois avec des données différentes. Les props permettraient de passer ces informations de manière dynamique.

  ```jsx
  function CarteUtilisateur(props) {
    return (
      <div>
        <h1>{props.nom}</h1>
        <p>Âge: {props.age}</p>
      </div>
    );
  }

  // Utilisation du composant avec différentes props
  <CarteUtilisateur nom="Alice" age={30} />
  <CarteUtilisateur nom="Bob" age={25} />
  ```

- **Exercice :**
  - Création d'un composant `ListeDeCourses` qui affiche une liste d'articles à acheter. Chaque article sera un composant enfant `Article` auquel on passera le nom de l'article via les props.

### Section 3.2 : Gestion de l’État Global avec Context API

- **Théorie :**
  - Le Context API est un moyen de partager des valeurs (état global) entre plusieurs composants sans avoir à passer explicitement les props à chaque niveau de l'arbre de composants.
  - Il est particulièrement utile pour partager des données qui peuvent être considérées comme "globales", comme les préférences utilisateur, les informations d'authentification, etc.

- **Exemple :**
  - Création d'un contexte de thème pour gérer un thème clair et sombre dans une application. Le contexte stockera l'état actuel du thème et sera accessible à tous les composants de l'application.

  ```jsx
  const ThemeContext = React.createContext();

  function App() {
    const [theme, setTheme] = useState('clair');

    return (
      <ThemeContext.Provider value={{ theme, setTheme }}>
        <Header />
        <ContenuPrincipal />
      </ThemeContext.Provider>
    );
  }

  function Header() {
    const { theme, setTheme } = useContext(ThemeContext);
    return (
      <header>
        <button onClick={() => setTheme(theme === 'clair' ? 'sombre' : 'clair')}>
          Changer le thème
        </button>
      </header>
    );
  }
  ```

- **Exercice :**
  - Création d'une application simple de blog où le Context API est utilisé pour gérer les informations de l'utilisateur connecté. Les composants du blog pourront accéder à ces informations sans avoir besoin de les recevoir explicitement en props.

### Section 3.3 : Routing avec React Router

- **Théorie :**
  - React Router est une bibliothèque de routage côté client pour React. Elle permet de gérer la navigation entre les différentes vues de l'application sans recharger la page.
  - Le routage est essentiel dans les applications React pour gérer les différentes pages, passer des paramètres dans l'URL, gérer l'historique de navigation, etc.

- **Exemple :**
  - Construction d'une application simple avec trois pages : Accueil, À propos et Contact. Utilisation de React Router pour naviguer entre ces pages.

  ```jsx
  import { BrowserRouter as Router, Route, Link } from "react-router-dom";

  function App() {
    return (
      <Router>
        <nav>
          <Link to="/">Accueil</Link>
          <Link to="/apropos">À propos</Link>
          <Link to="/contact">Contact</Link>
        </nav>

        <Route path="/" exact component={Accueil} />
        <Route path="/apropos" component={APropos} />
        <Route path="/contact" component={Contact} />
      </Router>
    );
  }
  ```

- **Exercice :**
  - Développement d'une petite application de galerie de photos avec plusieurs catégories. Utilisation de React Router pour créer des routes distinctes pour chaque catégorie de photos.

## Section 4 : Hooks et Patterns Avancés

---

### Section 4.1 : Hooks Personnalisés

#### Théorie

Les hooks personnalisés permettent de créer des fonctions réutilisables qui peuvent manipuler l’état ou le cycle de vie d’un composant. Ils offrent une façon d'extraire la logique des composants pour une meilleure modularité et réutilisation.

#### Exemple

Création d’un hook personnalisé `useFetch` pour simplifier les appels API.

```javascript
const useFetch = (url) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch(url)
      .then((response) => response.json())
      .then((data) => setData(data))
      .catch((error) => setError(error))
      .finally(() => setLoading(false));
  }, [url]);

  return { data, loading, error };
};
```

#### Explications

Ce hook utilise `useState` pour gérer les états de données, chargement et erreurs. `useEffect` est utilisé pour exécuter le fetch lorsque l’URL change. Ce hook peut maintenant être réutilisé dans différents composants pour faire des appels API.

#### Exercice

Créer un hook personnalisé `useLocalStorage` qui permet de stocker et récupérer une valeur depuis le localStorage.

---

### Section 4.2 : Gestion des Effets avec useEffect

#### Théorie

`useEffect` est utilisé pour exécuter des effets secondaires dans les composants fonctionnels, comme les appels API, les abonnements, ou manuellement changer le DOM. Il remplace les méthodes de cycle de vie comme `componentDidMount`, `componentDidUpdate`, et `componentWillUnmount` dans les composants de classe.

#### Exemple

Utilisation de `useEffect` pour mettre à jour le titre de la page en fonction du contenu d’un input.

```javascript
const TitleComponent = () => {
  const [title, setTitle] = useState("");

  useEffect(() => {
    document.title = title;
  }, [title]);

  return (
    <input
      value={title}
      onChange={(e) => setTitle(e.target.value)}
      placeholder="Changez le titre de la page"
    />
  );
};
```

#### Explications

Dans cet exemple, à chaque fois que la valeur de `title` change, `useEffect` est appelé pour mettre à jour le titre de la page. Le tableau de dépendances `[title]` s’assure que l’effet ne s’exécute que lorsque `title` change.

#### Exercice

Créer un composant qui charge des données depuis une API et les affiche, en utilisant `useEffect` pour l'appel API.

---

### Section 4.3 : Contexte Avancé et Optimisation des Performances

#### Théorie

Le contexte permet de partager des données entre tous les composants, sans avoir à passer explicitement les props à chaque niveau. Pour optimiser les performances, on peut utiliser `React.memo`, `useCallback` et `useMemo` pour éviter les rendus inutiles.

#### Exemple

Création d’un contexte pour gérer un thème (clair/sombre) dans une application.

```javascript
const ThemeContext = React.createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState("clair");

  const toggleTheme = () => {
    setTheme(theme === "clair" ? "sombre" : "clair");
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};
```

#### Explications

`ThemeContext` est un contexte qui contient le thème actuel et une fonction pour le changer. `ThemeProvider` est un composant qui englobe les composants enfants et leur fournit l’accès au contexte.

#### Exercice

Implémenter un composant `Header` qui change de couleur en fonction du thème et un bouton pour changer le thème, en utilisant `ThemeContext`.

---

Ces sections avancées sur les hooks et les patterns en ReactJS fournissent aux apprenants des compétences cruciales pour créer des applications React performantes et maintenables. Les exemples et exercices sont conçus pour renforcer la compréhension et encourager la pratique.

## Section 5 : React et les Appels API

Le travail avec des API est un élément fondamental du développement web moderne. Cette section se concentre sur comment utiliser React pour interagir avec les API, en utilisant des méthodes telles que Fetch et Axios, et comment gérer les états de chargement et les erreurs qui peuvent survenir lors de ces interactions.

### Section 5.1 : Fetch et Axios pour les Appels API

- **Théorie :**
  - **Fetch :** Intégré dans la plupart des navigateurs modernes, Fetch fournit un moyen simple d'effectuer des appels réseau. Explication de la syntaxe de base, de la promesse retournée par Fetch, et de la gestion des réponses JSON.
  - **Axios :** Une bibliothèque externe qui offre des fonctionnalités supplémentaires par rapport à Fetch. Présentation des avantages d'Axios, tels que l'annulation des requêtes, la protection contre les attaques XSRF, et la facilité de configuration des en-têtes par défaut.

- **Exemple :**
  - **Utilisation de Fetch :** Récupération et affichage d'une liste d'utilisateurs depuis une API publique telle que JSONPlaceholder.
  - **Utilisation d'Axios :** Réalisation du même appel, mais avec Axios, en soulignant les différences et les avantages.

- **Exercice :**
  - Création d'une petite application "Blog" qui récupère et affiche les articles depuis une API publique. L'exercice guide les étudiants à travers l'utilisation de Fetch et Axios, et met l'accent sur la gestion des réponses et des erreurs.

### Section 5.2 : Gestion des États de Chargement et Erreurs

- **Théorie :**
  - Introduction aux états de chargement, à l'importance de fournir un retour visuel aux utilisateurs pendant le chargement des données.
  - Techniques de gestion des erreurs lors des appels API, importance de l'affichage des messages d'erreur appropriés.

- **Exemple :**
  - Intégration d'indicateurs de chargement dans l'application "Blog".
  - Gestion des erreurs de réseau et affichage de messages d'erreur conviviaux.

- **Exercice :**
  - Ajout d'un indicateur de chargement et d'une gestion d'erreur à un composant existant qui effectue un appel API. L'objectif est de rendre l'interface utilisateur plus réactive et informative.

### Section 5.3 : Hook useReducer pour la Gestion d’État Complexe

- **Théorie :**
  - Introduction au hook `useReducer`, qui est utile pour gérer des états d'application plus complexes, en particulier ceux qui nécessitent plusieurs sous-valeurs ou lorsque la logique de mise à jour est complexe.
  - Comparaison avec `useState` et explication de quand utiliser `useReducer`.

- **Exemple :**
  - Réécriture d'une partie de l'application "Blog" en utilisant `useReducer` pour gérer l'état global des articles, y compris le chargement, les données et les erreurs.

- **Exercice :**
  - Conversion d’un composant utilisant `useState` en `useReducer`. Cela inclut la définition d'un `reducer`, l'initialisation d'un état, et l'utilisation du dispatch pour gérer les actions.

En complétant cette section, les étudiants auront une compréhension approfondie de la manière dont React interagit avec les API externes, des techniques pour gérer les états de chargement et les erreurs, ainsi que des compétences avancées dans la gestion de l'état avec `useReducer`. Ces compétences sont essentielles pour tout développeur ReactJS aspirant à construire des applications robustes et conviviales.

## Section 6 : Tests et Bonnes Pratiques en ReactJS

---

### Section 6.1 : Tests Unitaires avec Jest et React Testing Library

---

#### Section 6.1.1 : Introduction à Jest et React Testing Library

**Théorie :**
Les tests jouent un rôle crucial pour garantir la qualité du code. Jest est un framework de tests pour JavaScript, et React Testing Library est une suite d'utilitaires pour tester les composants React de manière plus réaliste.

**Exemple :**
Supposons que nous voulions tester une fonction simple qui ajoute deux nombres :

```javascript
function sum(a, b) {
  return a + b;
}
```

Avec Jest, le test serait :

```javascript
test('la fonction sum ajoute correctement deux nombres', () => {
  expect(sum(1, 2)).toBe(3);
});
```

**Explication :**
Dans cet exemple, la fonction `test` de Jest définit un nouveau test. La fonction `expect` est utilisée pour déclarer ce que nous attendons que notre code fasse, et `toBe` est une assertion qui vérifie le résultat.

---

#### Section 6.1.2 : Tester des Composants React avec React Testing Library

**Théorie :**
React Testing Library permet de tester des composants React de manière à ce qu'ils soient fidèles à la façon dont les utilisateurs interagissent avec votre application. Contrairement à d'autres bibliothèques, elle ne permet pas de tester les détails d'implémentation mais se concentre plutôt sur ce que l'utilisateur voit et fait.

**Exemple :**
Prenons le composant `Greeting` mentionné précédemment :

```javascript
function Greeting({ userName }) {
  return <div>Bienvenue, {userName}!</div>;
}
```

Avec React Testing Library, le test ressemblerait à :

```javascript
import { render, screen } from '@testing-library/react';
import Greeting from './Greeting';

test('affiche un message de bienvenue avec le nom d’utilisateur', () => {
  render(<Greeting userName="Alice" />);
  const greetingMessage = screen.getByText('Bienvenue, Alice!');
  expect(greetingMessage).toBeInTheDocument();
});
```

**Explication :**
Ici, nous utilisons `render` pour rendre le composant, puis `screen.getByText` pour trouver le texte à l'écran. Enfin, nous vérifions avec `expect` que le texte est présent dans le document.

---

#### Section 6.1.3 : Stratégies de Mocking et de Simulations d'Événements

**Théorie :**
Lors de la réalisation de tests, il est souvent nécessaire de "simuler" certaines parties de l'application, que ce soit des appels API ou des interactions utilisateur. Jest fournit des fonctions de "mocking" pour cela, et React Testing Library permet de simuler des événements.

**Exemple :**
Si nous avions un composant qui utilise un appel API pour récupérer des données, nous pourrions vouloir "simuler" cet appel pour rendre le test plus rapide et indépendant du réseau. De même, si un composant change suite à une interaction utilisateur (comme un clic de bouton), React Testing Library nous permet de simuler cet événement.

```javascript
import { render, screen, fireEvent } from '@testing-library/react';

test('le bouton cliqué incrémente le compteur', () => {
  render(<Counter />);
  const button = screen.getByRole('button');
  fireEvent.click(button);
  const count = screen.getByText('Compte: 1');
  expect(count).toBeInTheDocument();
});
```

**Explication :**
Dans cet exemple, nous utilisons `fireEvent` de React Testing Library pour simuler un clic sur un bouton. Ensuite, nous vérifions que le texte s'est bien mis à jour pour refléter le changement attendu.

---

J'espère que cela donne une vue détaillée de la section 6.1 concernant les tests en React avec Jest et React Testing Library.

### Section 6.2 : Bonnes Pratiques en ReactJS

#### Section 6.2.1 : Structure et Organisation du Projet

##### Théorie

Une structure de projet cohérente est essentielle pour la maintenabilité et la lisibilité du code. Il est recommandé de séparer les composants, les styles, les tests, et les ressources dans des dossiers distincts.

##### Exemple

- Structure recommandée :

  ```
  src/
  ├── components/
  ├── styles/
  ├── tests/
  └── assets/
  ```

- Chaque composant devrait avoir son propre dossier contenant le fichier JSX et le fichier de style associé.

##### Explication

Cette structure permet une navigation facile dans le projet et rend le code plus accessible, en particulier pour les nouveaux développeurs qui rejoignent le projet.

##### Exercice

Prenez un projet React existant avec une structure désorganisée. Réorganisez-le en suivant la structure recommandée.

#### Section 6.2.2 : Réutilisation des Composants et Props

##### Théorie

La réutilisation des composants permet de réduire la duplication de code et d’améliorer la maintenabilité. Les props permettent de passer des données et des fonctions entre les composants.

##### Exemple

Création d'un composant `Button` réutilisable :

```javascript
function Button({ children, onClick }) {
  return (
    <button onClick={onClick}>
      {children}
    </button>
  );
}
```

##### Explication

Ce composant `Button` peut être utilisé à plusieurs endroits dans l'application avec différents contenus et comportements, grâce à l’utilisation des props.

##### Exercice

Identifiez un élément qui se répète dans votre application (par exemple, une carte d’article, un en-tête, etc.) et transformez-le en composant réutilisable.

#### Section 6.2.3 : Gestion Efficace des États et Performance

##### Théorie

La gestion efficace des états est cruciale pour la performance de l'application. Utilisez les hooks d'état (useState, useReducer) à bon escient et évitez les mises à jour inutiles.

##### Exemple

Utilisation de `React.memo` pour éviter des rendus inutiles :

```javascript
const MyComponent = React.memo(function MyComponent(props) {
  /* render using props */
});
```

##### Explication

`React.memo` est une optimisation de performance qui permet à votre composant de ne se rerendre que si les props ont changé.

##### Exercice

Prenez un composant de votre application qui se rend souvent et appliquez `React.memo`. Comparez les performances avant et après.

#### Section 6.2.4 : L’Importance des Tests

##### Théorie

Les tests aident à prévenir les régressions et à s'assurer que le code fonctionne comme prévu. Ils devraient faire partie intégrante du processus de développement.

##### Exemple

Écrire un test pour vérifier qu'un composant affiche le bon message lorsque l'état change.

##### Explication

Ce test garantit que le composant se comporte correctement même après des modifications ultérieures du code.

##### Exercice

Prenez un composant qui n’a pas de test dans votre application et rédigez un test unitaire pour celui-ci.

#### Section 6.2.5 : Bonnes Pratiques de Codage

##### Théorie

Des pratiques de codage telles que la décomposition des composants en petites unités, l’utilisation de commentaires où nécessaire, et le respect des conventions de nommage, sont cruciales pour la lisibilité et la maintenabilité du code.

##### Exemple

- Découper un grand composant en sous-composants plus petits et réutilisables.
- Utiliser des noms descriptifs pour les fonctions et les variables.

##### Explication

Cela facilite la compréhension et la modification du code par vous-même ou par d'autres développeurs à l'avenir.

##### Exercice

Prenez un grand composant de votre application et décomposez-le en sous-composants plus petits. Assurez-vous également que le nommage est clair et descriptif.

### Section 6.3 : Déploiement d'une Application React

#### Section 6.3.1 : Préparation au Déploiement

**Théorie :**
Avant de déployer une application React, il est crucial de s'assurer que l'application est prête pour la production. Cela inclut l'optimisation des performances, la suppression des logs de débogage, la mise à jour des variables d'environnement, et la garantie que tous les tests passent.

**Exemple :**
Dans votre projet React, vous pourriez avoir utilisé `console.log` pour le débogage. Avant le déploiement, assurez-vous de supprimer ces logs pour éviter d'exposer des informations sensibles ou inutiles.

**Explication :**
Les logs de débogage peuvent ralentir l'application et ne sont généralement pas utiles pour les utilisateurs finaux. De plus, ils peuvent révéler des informations qui ne devraient pas être publiques.

**Exercice :**
Passez en revue votre code pour retirer les logs de débogage, vérifier les tests unitaires et mettre à jour les variables d'environnement pour la production.

#### Section 6.3.2 : Choix de la Plateforme de Déploiement

**Théorie :**
Il existe de nombreuses plateformes pour déployer des applications React, chacune ayant ses propres avantages. Des services comme Netlify, Vercel et GitHub Pages sont populaires pour leur simplicité et leur intégration facile avec les dépôts de code.

**Exemple :**
Netlify offre une intégration directe avec GitHub, permettant un déploiement continu à chaque push dans la branche principale. De plus, il fournit des fonctionnalités telles que la prévisualisation des pull requests et le rollback facile.

**Explication :**
Le déploiement continu simplifie le processus de mise à jour de votre application, car chaque modification validée est automatiquement déployée. Les prévisualisations des pull requests permettent de voir les changements avant qu'ils ne soient fusionnés dans la branche principale.

**Exercice :**
Créez un compte sur Netlify et explorez ses fonctionnalités. Associez un projet React de test à votre compte pour comprendre le processus de déploiement.

#### Section 6.3.3 : Processus de Déploiement sur Netlify

**Théorie :**
Le déploiement sur Netlify est généralement un processus simple et direct. Il implique la connexion à votre dépôt de code et la configuration de quelques paramètres de build.

**Exemple :**
Une fois connecté à Netlify et votre dépôt GitHub sélectionné, vous devez spécifier la commande de build (`npm run build`) et le dossier de publication (généralement `build/` pour les applications React).

**Explication :**
Netlify exécute la commande de build pour créer une version optimisée de votre application. Il déploie ensuite le contenu du dossier spécifié, rendant votre application accessible en ligne.

**Exercice :**
Déployez une application React sur Netlify. Modifiez ensuite quelque chose dans votre application, poussez les changements sur GitHub et observez le déploiement continu en action. Testez également le processus de prévisualisation des pull requests en créant une pull request dans votre dépôt GitHub.

## Section 7 : Préparation à l'Entretien d'Embauche pour Développeur ReactJS

---

### Section 7.1 : Questions Fréquentes en Entretien

---

#### Section 7.1.1 : Comprendre JSX

##### Théorie

JSX est une extension syntaxique pour JavaScript, recommandée par React pour décrire l'interface utilisateur. Il ressemble à du HTML, mais fonctionne avec la puissance de JavaScript.

##### Exemple de Question

**Q :** Expliquez ce qu’est JSX et pourquoi il est utilisé dans React.

**R :** JSX est une syntaxe qui ressemble à du HTML et qui est utilisée pour écrire des composants React. Elle est transpilée en appels à `React.createElement()` par Babel. Elle permet d'écrire la structure des composants de manière plus lisible et déclarative, tout en bénéficiant des fonctionnalités de JavaScript.

---

#### Section 7.1.2 : Composants, État et Props

##### Théorie

Dans React, les composants sont les éléments de base de toute application. L’état (state) et les props sont des concepts essentiels pour gérer les données dans et entre les composants.

##### Exemple de Question

**Q :** Quelle est la différence entre l’état (state) et les props dans React ?

**R :** L’état représente les données qui peuvent changer au cours du temps dans un composant. Les props sont des données passées au composant par un parent et sont immuables dans le contexte du composant enfant. L'état est local au composant, tandis que les props sont utilisées pour communiquer entre les composants.

---

#### Section 7.1.3 : Lifecycle et Hooks

##### Théorie

Le cycle de vie d'un composant React décrit les différentes étapes de sa vie, depuis sa création jusqu'à sa destruction. Les Hooks, introduits dans React 16.8, permettent d’utiliser l’état et d’autres fonctionnalités de React sans écrire de classe.

##### Exemple de Question

**Q :** Pouvez-vous expliquer le cycle de vie d’un composant en React et l'utilisation des Hooks ?

**R :** Un composant React passe par plusieurs étapes : montage, mise à jour et démontage. Les méthodes du cycle de vie comme `componentDidMount`, `componentDidUpdate`, et `componentWillUnmount` permettent de gérer les comportements à ces différentes étapes. Avec l'introduction des Hooks, on utilise `useEffect` pour gérer les effets secondaires, `useState` pour l'état local, entre autres.

---

#### Section 7.1.4 : Gestion de l'État et Patterns

##### Théorie

La gestion de l'état est cruciale dans les applications React. Des patterns comme la remontée d'état (lifting state up) et l'utilisation de contextes ou de bibliothèques comme Redux sont essentiels.

##### Exemple de Question

**Q :** Comment gérez-vous l'état dans une application React complexe ?

**R :** Pour des applications complexes, j’utilise souvent Redux pour gérer un état global. Pour les états locaux, j’utilise `useState` ou `useReducer`. Pour partager l’état entre des composants proches, la remontée d’état ou l’utilisation de l’API Context de React peut être une bonne solution.

---

#### Section 7.1.5 : Performances et Optimisation

##### Théorie

L'optimisation des performances est un aspect crucial, notamment pour les grandes applications. La compréhension de la réconciliation, l'utilisation judicieuse de `React.memo`, et le fractionnement de code sont des éléments clés.

##### Exemple de Question

**Q :** Comment optimisez-vous les performances dans une application React ?

**R :** Pour optimiser les performances, j’utilise `React.memo` pour éviter les rendus inutiles, `useCallback` et `useMemo` pour mémoriser des fonctions et valeurs. Je fais également attention à la structure des composants pour éviter les re-rendus inutiles et j’utilise le fractionnement de code pour charger des ressources seulement lorsque c’est nécessaire.

---

#### Section 7.1.2 : Composants, État et Props

##### Théorie

Dans React, les composants sont les éléments de base de toute application. L’état (state) et les props sont des concepts essentiels pour gérer les données dans et entre les composants.

##### Exemple de Question

**Q :** Quelle est la différence entre l’état (state) et les props dans React ?

**R :** L’état représente les données qui peuvent changer au cours du temps dans un composant. Les props sont des données passées au composant par un parent et sont immuables dans le contexte du composant enfant. L'état est local au composant, tandis que les props sont utilisées pour communiquer entre les composants.

---

#### Section 7.1.3 : Lifecycle et Hooks

##### Théorie

Le cycle de vie d'un composant React décrit les différentes étapes de sa vie, depuis sa création jusqu'à sa destruction. Les Hooks, introduits dans React 16.8, permettent d’utiliser l’état et d’autres fonctionnalités de React sans écrire de classe.

##### Exemple de Question

**Q :** Pouvez-vous expliquer le cycle de vie d’un composant en React et l'utilisation des Hooks ?

**R :** Un composant React passe par plusieurs étapes : montage, mise à jour et démontage. Les méthodes du cycle de vie comme `componentDidMount`, `componentDidUpdate`, et `componentWillUnmount` permettent de gérer les comportements à ces différentes étapes. Avec l'introduction des Hooks, on utilise `useEffect` pour gérer les effets secondaires, `useState` pour l'état local, entre autres.

---

#### Section 7.1.4 : Gestion de l'État et Patterns

##### Théorie

La gestion de l'état est cruciale dans les applications React. Des patterns comme la remontée d'état (lifting state up) et l'utilisation de contextes ou de bibliothèques comme Redux sont essentiels.

##### Exemple de Question

**Q :** Comment gérez-vous l'état dans une application React complexe ?

**R :** Pour des applications complexes, j’utilise souvent Redux pour gérer un état global. Pour les états locaux, j’utilise `useState` ou `useReducer`. Pour partager l’état entre des composants proches, la remontée d’état ou l’utilisation de l’API Context de React peut être une bonne solution.

---

#### Section 7.1.5 : Performances et Optimisation

##### Théorie

L'optimisation des performances est un aspect crucial, notamment pour les grandes applications. La compréhension de la réconciliation, l'utilisation judicieuse de `React.memo`, et le fractionnement de code sont des éléments clés.

##### Exemple de Question

**Q :** Comment optimisez-vous les performances dans une application React ?

**R :** Pour optimiser les performances, j’utilise `React.memo` pour éviter les rendus inutiles, `useCallback` et `useMemo` pour mémoriser des fonctions et valeurs. Je fais également attention à la structure des composants pour éviter les re-rendus inutiles et j’utilise le fractionnement de code pour charger des ressources seulement lorsque c’est nécessaire

---

### Section 7.2 : Cas d'Usage et Projets à Présenter

#### Théorie

Pour se démarquer lors d'un entretien, il est essentiel de pouvoir discuter de cas d'utilisation concrets et de présenter des projets personnels ou professionnels où vous avez utilisé ReactJS. Cela montre non seulement votre compréhension théorique, mais aussi votre capacité à appliquer ces connaissances dans des scénarios pratiques.

---

#### Section 7.2.1 : Application E-commerce

##### Description du Projet

Développement d'une interface utilisateur pour un site e-commerce. Le projet implique l'utilisation de React pour gérer les interactions utilisateur, comme la navigation entre les produits, l'ajout d'articles au panier, et le processus de paiement.

##### Points Clés à Discuter

- **Gestion de l'État Global :** Utilisation de Redux ou de la Context API pour gérer l'état global de l'application, comme le panier d'achat et les informations utilisateur.
- **Optimisation des Performances :** Mise en œuvre de `React.memo` et `useCallback` pour éviter les rendus inutiles, en particulier dans les listes de produits.
- **Navigation :** Utilisation de React Router pour gérer la navigation entre différentes pages et composants.

##### Exemple d'Implémentation

- Montrez comment vous avez structuré les composants de votre application, en expliquant pourquoi vous avez choisi cette architecture.
- Discutez d'un défi spécifique rencontré, par exemple la gestion de l'état du panier sur plusieurs pages, et comment vous l'avez résolu.

##### Exercice

Analysez une fonctionnalité de votre application e-commerce, comme la page de détails du produit. Comment pourriez-vous l'améliorer ou la rendre plus performante ?

---

#### Section 7.2.2 : Application de Gestion de Tâches

##### Description du Projet

Création d'une application de gestion de tâches permettant aux utilisateurs de créer, trier, filtrer et marquer des tâches comme complétées. Le projet comprend également des fonctionnalités d'authentification et de stockage des tâches.

##### Points Clés à Discuter

- **Hooks Personnalisés :** Utilisation de Hooks personnalisés pour extraire et réutiliser la logique métier.
- **Intégration Backend :** Communication avec une API backend pour la persistance des tâches.
- **Tests Unitaires :** Mise en place de tests unitaires avec Jest et React Testing Library pour assurer la fiabilité du code.

##### Exemple d'Implémentation

- Présentez la structure de vos composants et comment les Hooks personnalisés ont aidé à simplifier votre code.
- Expliquez un problème spécifique, tel que la gestion des états de chargement et d'erreur lors des requêtes API, et comment vous l'avez adressé.

##### Exercice

Prenez une fonctionnalité de l'application, comme le filtre des tâches, et réfléchissez à comment vous pourriez l'améliorer en termes d'expérience utilisateur ou de performance.

---

#### Conseil Final

Lorsque vous présentez ces projets lors de votre entretien, assurez-vous de bien articuler le raisonnement derrière chaque choix technique et de montrer comment vous avez résolu des problèmes spécifiques. Cela démontrera non seulement vos compétences techniques, mais aussi votre capacité à réfléchir de manière critique et à apporter des solutions efficaces.

---

### Section 7.3 : Compréhension des Subtilités de ReactJS et Bonnes Pratiques

---

#### Section 7.3.1 : La Composition par Rapport à l'Héritage

##### Théorie

En React, la composition est préférée à l'héritage pour réutiliser le code entre les composants. Cela permet une plus grande flexibilité et une meilleure encapsulation.

##### Exemple

- **Cas de Composition :** Utilisation de composants enfants pour personnaliser un composant de 'Layout'. Au lieu d'étendre la classe 'Layout', vous pouvez passer les composants 'Header' et 'Footer' en tant que props.

##### Exercice

Créez un composant 'Page' qui accepte des composants 'Header', 'Main' et 'Footer' en tant que props et les affiche. Réfléchissez à la manière dont cela offre plus de flexibilité qu'une approche basée sur l'héritage.

---

#### Section 7.3.2 : Immutabilité de l’État

##### Théorie

L'état dans React doit être traité comme immuable. La modification directe de l'état peut conduire à des comportements incohérents et des bugs difficiles à déceler.

##### Exemple

- **Mauvaise Pratique :** `this.state.items.push(newItem)` est une mauvaise pratique car elle modifie directement l'état.
- **Bonne Pratique :** Utilisez `this.setState({ items: [...this.state.items, newItem] })` pour maintenir l'immutabilité.

##### Exercice

Prenez un composant qui modifie directement son état. Refactorez-le pour assurer l'immutabilité de l'état. Observez les changements dans le comportement du composant.

---

#### Section 7.3.3 : Utilisation de Fragments et d'Attributs Clés

##### Théorie

Les fragments permettent de regrouper une liste d'éléments sans ajouter de nœuds supplémentaires au DOM. L'utilisation de clés uniques est cruciale pour l'efficacité du processus de réconciliation de React, en particulier dans les listes.

##### Exemple

- **Fragment :** `<React.Fragment>...</React.Fragment>` ou la syntaxe courte `<>...</>` pour envelopper une liste de composants frères sans élément parent supplémentaire.
- **Clés :** Dans une liste, utilisez des clés uniques pour chaque élément. Par exemple, `<li key={item.id}>...</li>`.

##### Exercice

Créez une liste de composants en utilisant des fragments. Ajoutez ensuite des clés uniques à chaque élément de la liste et observez comment cela affecte le rendu et les performances lors de la mise à jour de la liste.

---

#### Section 7.3.4 : Optimisation des Performances avec React.memo et useCallback

##### Théorie

`React.memo` est un HOC (Higher-Order Component) qui optimise les composants fonctionnels en évitant les rendus inutiles. `useCallback` est un Hook qui retourne une version mémorisée d'une fonction de rappel.

##### Exemple

- **React.memo :** Utilisez `React.memo` pour envelopper un composant qui n’a pas besoin d’être rendu si ses props n'ont pas changé.
- **useCallback :** Utilisez `useCallback` pour des fonctions passées en tant que props aux composants enfants pour éviter des rendus inutiles.

##### Exercice

Identifiez un composant dans votre application qui se rend souvent sans raison. Appliquez `React.memo` et utilisez `useCallback` pour les fonctions passées en tant que props. Mesurez les améliorations de performance.

---

#### Section 7.3.5 : Séparation des Préoccupations

##### Théorie

La séparation des préoccupations implique de diviser un programme en sections distinctes, chacune traitant d'une préoccupation distincte. En React, cela se traduit souvent par la séparation de la logique métier des composants de présentation.

##### Exemple

- **Cas Pratique :** Un composant 'UserList' qui à la fois récupère des données utilisateur et les affiche. Séparez la logique de récupération des données dans un Hook personnalisé ou un composant de conteneur, laissant 'UserList' se concentrer uniquement sur la présentation.

##### Exercice

Prenez un composant 'monolithique' de votre code. Séparez les préoccupations en extrayant la logique d'affaires, la gestion de l'état et les appels API dans des Hooks personnalisés ou des composants de conteneur. Observez comment cette séparation améliore la lisibilité et la maintenabilité du code.
